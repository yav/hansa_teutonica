local vp_tile_url = "http://cloud-3.steamusercontent.com/ugc/1019448055772843763/A8B835D424CCDB36586A94B69E07354C77A3FFE2/"
local site_url = "http://cloud-3.steamusercontent.com/ugc/1019448055772843418/61B4491C971CB42104AE69CA2DBCEE05885CF15E/"
local board_url = "http://cloud-3.steamusercontent.com/ugc/1019448055771758789/B94E062E2A88B6DF6C4A4BF17783273E8EDDC669/"
local rules_url = "http://cloud-3.steamusercontent.com/ugc/1019448055771117883/849164530290FDE0B09F974FF601BCE50DF08FF8/"

local event_url = "http://cloud-3.steamusercontent.com/ugc/1046470917543956033/EF047905FABE5BDB0F887D90402BEB25C3F0B185/"
local hammer_url = "http://cloud-3.steamusercontent.com/ugc/1046471563476550220/382A05ABABFD37DD21E1BD89AEF2538C97ABBDF3/"


local leader_url =
{ "http://cloud-3.steamusercontent.com/ugc/1019448689708835346/33A82F9A6AB6A69402F9203C71C9CFCF204AC168/"
, "http://cloud-3.steamusercontent.com/ugc/1019448689708835678/093CCA4A3019179EED7F47DDB24099B509710B24/"
, "http://cloud-3.steamusercontent.com/ugc/1019448689708836098/B40054133690B80FE346B8028EAFF416E65B3031/"
, "http://cloud-3.steamusercontent.com/ugc/1019448689708836747/D4D9B9DD41BEB0B718DEE53024316DB5F55BEBB9/"
, "http://cloud-3.steamusercontent.com/ugc/1046470585559819700/F83AB4A09B1A461A85B8D67ACA2599A498C66150/"
}


local leader_img_url =
{
{ "http://cloud-3.steamusercontent.com/ugc/1046470917539271167/5CA1E6AE9101A8551CD89B31C98508BA12F42307/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539336005/9E107B532C02D4D8B33243DE5D9261CA386D2255/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539336717/4D6AA4B6261D0C5D7B55530432DD307F21C44615/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539337119/392255D1E0E24C7ED24E2F73F46603AFABEAB630/"
}
,
{ "http://cloud-3.steamusercontent.com/ugc/1046470917539337518/4A11291F944B4CEA8A5735D13E54F45359E6EFC7/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539337979/2345E6EA3D1374C9208CC985CC79466FB5F91133/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539341926/B97ABF01E70F70DF381864D28E46AF4F5FF262D9/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539338437/2E75028259B467849B2DF9C22FA267D1CD322DCC/"
}
,
{ "http://cloud-3.steamusercontent.com/ugc/1046470917539338828/EB2D1E1F84D018D6438CC27E14469158D1F8EBDA/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539339760/BDC18479215BB17A10AB6EEA0850158E596A39B1/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539342707/1854619BF81F00746ADC11BA058E8DD1C11432EB/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539343248/F8D3591E72BA07FBF8D22079DAE3C85583646F79/"
}
,
{ "http://cloud-3.steamusercontent.com/ugc/1046470917539343685/EAC49B131D43C79C49E5A507B191E5A4562659C3/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539344024/0495185A3777FAC8C6D728B22249D6D91F33FA69/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539344534/0CA9ACE1EEB5CC6671993B510488A89AD815FC1C/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539344905/8E46A377287D1ED098AC7E108CF38698BA98FBFA/"
}
,
{ "http://cloud-3.steamusercontent.com/ugc/1046470917539345601/46ECFB1D7CE0B8E12BF1943579823C7DBE36249D/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539345926/7A06B764328E9139E4915D5C9D4D15117168381C/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539347429/DDE0F74290F4B79C4AA3C23F15AEC3F942B0958A/"
, "http://cloud-3.steamusercontent.com/ugc/1046470917539347932/D9AD1F79816428DA0EEA30D63EE34C573BECA1D5/"
}
}


local map_tile_url =
  {
  { "http://cloud-3.steamusercontent.com/ugc/1019448055772831863/98E33434D042107508380E1C54432375EF832371/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772837770/58A55AF2C51CA42DD081A9ED1C751244B6B057A0/"
  , "http://cloud-3.steamusercontent.com/ugc/1046471563476552608/53D80928290022BD8ACCBF7AF36C043124FC5A0A/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772838335/97BA9C5442D074CB86680A1F1A8BFD6A8F5BB87E/"
  },
  { "http://cloud-3.steamusercontent.com/ugc/1019448055772838905/4D975D4220DBE5D4CB2ED23B55E8BF8502DC6ACE/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772839231/3F62D8237CA18A0644C49F7AAB763F7B9F11ACAE/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772839489/872BD338964F814D029BAE713A5E302568EF4314/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772839764/50B61D49EECFC4406EF348465001CA0928606D9E/"
  },
  { "http://cloud-3.steamusercontent.com/ugc/1019448055772840044/44FF945E092E8D2A97ED30496BCC082EBEF1951F/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772887719/4AAE2836382AC3F7E4E98AD474350A144400AECD/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772840671/E0A5F887CAB54065F71119A422F5662CEB390B51/"
  , "http://cloud-3.steamusercontent.com/ugc/1046471563476558518/346D54703DF5F5A9BA4290E5D12FE34325B1D398/"
  },
  { "http://cloud-3.steamusercontent.com/ugc/1019448055772842574/8FBDB1D137643CBFFAEEAD3E10E6555C156DA664/"
  , "http://cloud-3.steamusercontent.com/ugc/1046471563476561436/9ACB2256DB45BE7D675F1683F2AA44515861114E/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772842898/A9CF928066F891000D52F1632119DA131206FDE3/"
  , "http://cloud-3.steamusercontent.com/ugc/1019448055772841887/982EE46E38BD2EA3C6EE28F51543BAED22B5333F/"
  }
  }


local build_url =
  {
  {
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774006757/438F0FAFF3289F7A88DAEA5D000BF0A45AC59899/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774007488/006E334BF0A1939639255CDFB68F9C2632817766/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774007777/0AF710067785B5DD2F67B697F87BE1B8AC5D2D68/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774008041/182EBF3E0A239381C13289D8E698260B14E79098/",
    },
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774008332/CFD214D7917B700D36E1E955C9398611088B0D1E/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774008617/F65D3A16E2329C4AA1AC190FED801F967C3D608A/",
    },
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774008887/23984FE94119FD85B88466B97A6DC194E7B45BF2/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774009204/C93C446F6DF98923BD4EFA265FC262B8BE838362/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774009579/8079B5F6215234F8761485C63F565E4B599F098E/",
    },
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774009903/EF8A3BB66034B90691D65AD50156C6B55AE7CAEB/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774010189/3388E1E435EB1209E8CB1CA2E15385C0D1A9BDE0/",
    }
  }
  ,
  {
      { "http://cloud-3.steamusercontent.com/ugc/1019448055774011006/7BD24E16E272B7719F791302F6069F148D20ED15/",
        "http://cloud-3.steamusercontent.com/ugc/1019448055774011409/134FA96440B2E241FBAAA044745C50D13ECF348B/",
       },
       {"http://cloud-3.steamusercontent.com/ugc/1019448055774012140/44E6C34ECEBF253B77BB7E463B5CD92A9A11A3D4/",
        "http://cloud-3.steamusercontent.com/ugc/1019448055774012506/47260036F67A18B8D6A352A5F760506DB1E4B4DC/",
        "http://cloud-3.steamusercontent.com/ugc/1019448055774012819/2E87551D610D72AAC8C301120E6E48DCBE2E1C09/",
        "http://cloud-3.steamusercontent.com/ugc/1019448055774013148/FB70A6DA8CD18BA9C9AEC2E2B02008B0AAE23ED0/",
       },
       {
        "http://cloud-3.steamusercontent.com/ugc/1019448055774013497/85E2F5EF3501593120EA80191CB75E6DB8DF5711/",
        "http://cloud-3.steamusercontent.com/ugc/1019448055774013827/39857AC1ABF730625610261A6EA726C366E8EB96/",
       },
       { "http://cloud-3.steamusercontent.com/ugc/1019448055774014289/25EB30BD5BA8AE3207D785DB672523C3257540BE/",
         "http://cloud-3.steamusercontent.com/ugc/1019448055774014818/D35D4EBB69963EE85F24A56793CFA322DBAA2B34/",
         "http://cloud-3.steamusercontent.com/ugc/1019448055774015269/2353BC6E5B0EE95E71458FD640D66B3C05F426BD/"
       }
    }

  ,
  {
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774016413/7EF4B0E5F7C3676A08A8051D7DF2B90527271856/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774016849/B3F81FBA084AEF85C46693482A521EE5B4FD2805/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774018337/6EA0CD3B63AE4749D741B870A7C3FE48C47544ED/",
    },
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774018829/A6BD7939DC2E7AF819B988B78484FC6A0C253E5D/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774019185/2BAAF54004262373698422D9D6BEAE3FEC0E154C/"
    },
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774019693/563448DC1B4ED22052D4E936DC5E099B3688BE92/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774020216/1492194E3178C2B0DAC2442EC803FC520848A626/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774020675/638106CCAB89C9351B1B3E8A0EAB582DFFEA17EF/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774021196/DE77DB9A00ACDCE1ED421A7737DA3F180A2E0D11/"
    },
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774021692/16C97BA402D7DA640D84BD08F0DC5A061925D80F/",
      "http://cloud-3.steamusercontent.com/ugc/1019448055774022079/9231A7013394788250453517BDC25F26FB0F5B74/"
    }
  }
  ,
  {
    { "http://cloud-3.steamusercontent.com/ugc/1019448055774023060/42A391E1C4A506C57B3DA831512390F87C57047C/"
    , "http://cloud-3.steamusercontent.com/ugc/1019448055774023600/0A4D4DE61116EBCB417AC95AFA7E83233F5CEBEC/"
  },
  { "http://cloud-3.steamusercontent.com/ugc/1019448055774023999/6892A25AC08D071792DCA99D7B9FA5FEC3FD5632/",
    "http://cloud-3.steamusercontent.com/ugc/1019448055774024380/78E3C086AAB50228399EF6BDE8B3CEB9E57D69AA/",
    "http://cloud-3.steamusercontent.com/ugc/1019448055774024733/310B6548A1053FC14D4291A7A97F59261CA4677C/"
  },
  { "http://cloud-3.steamusercontent.com/ugc/1019448055774025073/B305DDCCD54B16D7002B1BE619E4DBBCD3A8FF4D/",
    "http://cloud-3.steamusercontent.com/ugc/1019448055774025394/9D074708D7271DAF6CBFD2DE1F22D72946EB55A1/"
  },
  { "http://cloud-3.steamusercontent.com/ugc/1019448055774025693/F119DD0BAFFB2BD11F78C116EC5E877166B0648B/",
    "http://cloud-3.steamusercontent.com/ugc/1019448055774026037/774602C6526CBC1CE7987903C8DC7F4ABCA70D27/",
    "http://cloud-3.steamusercontent.com/ugc/1019448055774026328/7E6349FC605928B9D8F1B92DB692E438469F4C08/",
    "http://cloud-3.steamusercontent.com/ugc/1019448055774026621/33DC713CFD4FA24F7ED52D632E2AA0FA068CA55D/"
  }
}
}


local zoneName = { "[CC00CC]Religious[-]"
                 , "[FF0000]Political[-]"
                 , "[FFFF00]Commercial[-]"
                 , "[0099FF]Cultural[-]"
                 , "[CCCCCC]Citadelle[-]"
               }


local leaders =
  { { "Mgr François de Montmorency-Laval"
    , "Mgr Jean-Olivier Briand"
    , "Mgr Elzéar-Alexandre Taschereau"
    , "Mgr Marc Ouellet"
    }
  , { "Samuel de Champlain"
    , "Louis-Joseph de Montcalm"
    , "Pierre-Joseph-Olivier Chauveau"
    , "Régis Labeaume"
    }
  , { "Jean Talon"
    , "Gilles Hocquart"
    , "Gabriel-Alphonse Desjardins"
    , "Peter Simons"
    }
  , { "Marc Lescarbot"
    , "Jean Baillairgé"
    , "François-Xavier Garneau"
    , "Robert Lepage"
    }
  , { "Louis de Buade de Frontenac"
    , "Gaspard-Joseph Chaussegros de Léry"
    , "Lord Dufferin"
    , "Michaëlle Jean"
    }
  }

local events =
  { e1603 =
      { "(1603) Samuel de Champlain's first voyage"
      , ""
      , "[End of Game]"
      , "Have the largest group of"
      , "adjacent buildings."
      , ""
      , "8 VP"
      }
  , e1663 =
      { "(1663) Birth of the Sovereign Council:"
      , "roots of the Québec government"
      , ""
      , "[Race]"
      , "Complete 6 buildings:"
      , "2 in 3 different colors."
      , ""
      , "1st: 8 VP    2nd: 4 VP"
      }
  , e1665 =
      { "(1665) Arrival of Jean Talon:"
      , "the first Intendant of Québec"
      ,""
      , "[Race]"
      , "Complete a 3-star building"
      , "in each color."
      , ""
      , "1st: 8 VP    2nd: 4 VP"
      }
  , e1682 =
      { "(1682) Fort Québec fire:"
      , "beginning of the French Canadian"
      , "architectural style"
      , ""
      , "[Race]"
      , "Complete 3 blue buildings."
      , ""
      , "1st: 8 VP    2nd: 4 VP"
      }

  , e1759 =
      { "(1759) Battle of the Plains of Abraham"
      , ""
      , "[Scoring]"
      , "Every player cascades influence"
      , "from the " .. zoneName[5]
      , "to the " .. zoneName[2] .. " authority."
      }

  , e1756 =
      { "(1756--1763) Seven Years' War"
      , ""
      , "[Century]"
      , "Players do not activate workers"
      , "when taking a leader."
      }

  , e1763 =
      { "(1763) Royal proclamation and"
      , "departure of the French elites"
      , ""
      , "[Century]"
      , "Players may not take a leader."
      }

   , e1775 =
      { "(1775) Fortification of Québec"
      , "against the American invasion"
      , ""
      , "[Century]"
      , "Buildings completed with"
      , "a single contribution do not get"
      , "an ownership token."
      }

  , e1800 =
      { "(1800--1830) Massive British immigration"
      , ""
      , "[Century]"
      , "When starting a building"
      , "players activate 4 workers."
      }

   , e1812 =
      { "(1812) War of 1812"
      , "against the United States"
      , ""
      , "[Century]"
      , "When starting a building"
      , "players activate 2 workers."
      }

   , e1867 =
      { "(1867) Québec becomes a provincial capital."
      , ""
      , "[Immediate]"
      , "Each player activates workers"
      , "equal to their rank on the scoring track."
      }

    , e1871 =
      { "(1871) Construction of naval canals:"
      , "decline of the Port of Québec"
      , ""
      , "[After Scoring]"
      , "Player may keep only 3 active workers."
      }

     , e1917 =
      { "(1917) Conscription crisis"
      , ""
      , "[Before Scoring]"
      , "Influence less than 3 is removed."
      }

     , e1955 =
      { "(1955) First official edition of the"
      , "Québec Winter Carnival"
      , ""
      , "[Before Scoring]"
      , "Players who have influence with all 5"
      , "authorities score 5 VP."
      }

      , e2001 =
      { "(2001) Summit of the Americas and"
      , "protest again globalization"
      , ""
      , "[Scoring]"
      , "Players may cascade only to"
      , "authorithies where they have"
      , "at least 1 influence."
      }

      , e2008 =
      { "(2008) Québec City's 400th Anniversary"
      , ""
      , "[Scoring]"
      , "Only players who had influence with"
      , "the 4 corrner authorities may cascade."
      }
  }

local eventsByAge =
  { { "e1603", "e1663", "e1665", "e1682" }
  , { "e1759", "e1756", "e1763", "e1775" }
  , { "e1800", "e1812", "e1867", "e1871" }
  , { "e1917", "e1955", "e2001", "e2008" }
  }


local map_data = {
  { { {1,7}, 1, "Archdiocese",         {{1,6}, {2,6} }},
    { {4,4}, 2, "Protestant District", {{3,3}, {5,4}, {3,5}} },
    { {8,4}, 2, "Irish District",      {{7,3}, {9,4}, {7,5}} },
    { {6,8}, 3, "Jewish District",     {{5,8}, {5,7}, {6,7}} }
  },
  { { {8,8}, 1, "Seat of Government",       {{7,7}, {8,7}} },
    { {5,3}, 2, "Municipal Administration", {{4,3}, {6,2}, {6,4}} },
    { {3,7}, 2, "National Administration",  {{2,7}, {4,6}, {4,8}} },
    { {1,3}, 3, "Millitary Administration", {{1,4}, {2,4}, {2,3}} }
  },
  { { {9,2}, 1, "Public Market",      {{8,3}, {9,3}} },
    { {6,5}, 2, "Buisiness District", {{7,4}, {5,5}, {7,6}} },
    { {2,5}, 2, "Rich District",      {{3,4}, {1,5}, {3,6}} },
    { {4,1}, 3, "Port District",      {{4,2}, {5,2}, {5,1}} }
  },
  { { {2,1}, 1, "Social Club",            {{2,2}, {3,2}} },
    { {7,2}, 2, "Entertainment District", {{6,1}, {8,2}, {6,3}} },
    { {5,6}, 2, "Academic District",      {{4,5}, {6,6}, {4,7}} },
    { {9,6}, 3, "Arts District",          {{8,6}, {8,5}, {9,5}} }
  },
}









local leaderD =
 { "You gain the district benefits when contributing to your own buildings."
 , "You choose which authority to influece with your contributions to completed buildings."
 , "You gain a second architect.  It automatically completes its building at the end of the round."
 , "Gain 2/3/4 VP when your architect completes a 1/2/3 star building.\n\n" ..
   "In a 2/3 player game you gain 1/2/3 VP instead."
 , "Spend 3 workers to gain 3 Citadelle influence."
}

local actionD = {
  { { "Activate any " .. zoneName[1] .. " district."
    }

  , { "- Spend 1 worker to gain 1 " .. zoneName[5] .. " influence."
    , "- Spend 1 worker to gain 1 other influence."
    }

  , { "- Gain 1 VP."
    , "- Activate 1 worker."
    , "- Spend 1 worker to gain 1 influnce."
    }

  , { "- Spend 1 worker to gain 1 influence."
    , "- Move 2 influence from 1 authority to another."
    }
  },

  { { "Activate any " .. zoneName[2] .. " administration."
    }

  , { "Spend 2 workers to gain 2 " ..
        zoneName[1] .." or " .. zoneName[3] .. " influence."
    }

  , { "Spend 2 workers to gain 2 " ..
         zoneName[2] .. " or " .. zoneName[4] .. " influence."
     }

  , { "Spend 2 workers to gain 2 " .. zoneName[5] .. " influence."
    }
  },

  { { "Activate any " .. zoneName[3] .. " district."
    }

  , { "Contribute to [i]another[/i] building"
    , " * May use passive workers."
    , " * Does not activate the building."
    }

  , { "Start a new building." }
  , { "Activate 3 workers." }
  },

  { { "Activate any " .. zoneName[4] .. " district." }
  , { "Score 1/3/4 VP if you have 1/2/3+ active workers." }
  , { "Score 1/3/4 VP if you have influence with 1/2/3+ authorities." }
  , { "Upgrade a completed bulding." }
  }
}


local zoneLoc = { {12,-9}, {-23.5,-9}, {-23.5,17}, {12,17}, {12,5.5} }
local zoneArrow = { {10,-7,135}, {-20,-7,-135},
                    {-19.5,14,-45}, {10,14,45},
                    {9,4.7,90} }


local ownLabels = { "*", "**", "***" }




-------------------------------------------------------------------------------
-- Static map info

local finalAge = 4
local hub = {}            -- maps building sites to actions
local spotByColor = {}    -- all spots of a given color (for setup)
local actions = { {}, {}, {}, {} } -- code for district actions
local allLocs = {}

function locId(l) return l[1] .. "_" .. l[2] end

function staticMapSetup(k)
  local sem = newSem()
  for i,xs in ipairs(map_data) do
     for j,x in ipairs(xs) do
       sem.up()
       setupLocation(i,j,x,sem.down)
     end
  end
  sem.wait(k)
end

function setupLocation(i,j,info, k)

  local name = info[3]

  local function act(gs,loc)
    local p = gsCurPlayer(gs)
    say(playerColorBB(p) .. " uses the " .. name)
    local fun = actions[i][j]
    fun(gs,loc)
  end

  local spots = {}
  for x,l in ipairs(info[4]) do
    local id = locId(l)
    spots[x] = id
    allLocs[id] = l
  end

  local id = locId(info[1])
  allLocs[id] = info[1]
  local me = {
    id = id,
    loc = info[1],
    requires = info[2],
    act = act,
    name = name,
    spots = spots,
    color = i
  }

  for _,x in ipairs(me.spots) do
    hub[x] = me
  end

  local objs = spotByColor[i]
  if not objs then
    objs = {}
    spotByColor[i] = objs
  end

  push(objs, me)

  local t = spawnObject({
    type = "Custom_Tile",
    position = grid(id,1.1,0,0),
    scale = { 1.35, 1.35, 1.35 },
    rotation = { 0, 180, 0 },
    callback_function = function(o)
      o.setLock(true)
      o.setName(name .. ", " .. zoneName[me.color])
      local d = "Contribution:\n  " .. me.requires .. " active worker"
      if me.requires > 1 then d = d .. "s" end
      d = d .. "\n\nActivation:"
      for _,ln in ipairs(actionD[i][j]) do
         d = d .. "\n  " .. ln
      end
      o.setDescription(d)
      k()
    end
  })
  t.setCustomObject({
    type = 2,
    thickness = 0.1,
    image = map_tile_url[i][j]
  })

end



function grid(pid,z,a,b)
  local p = allLocs[pid]
  local x0 = -24
  local y0 = 15.1

  local y = p[2]
  local x = p[1] + y%2/2

  local dx = 3.02
  local dy = -2.666
  local extra = y%2 / 2
  local ox = a/2
  local oy = b/2
  return { x0 + ox + x * dx, z, y0 + oy + y * dy }
end

function neighbours(pid)

  local pos = allLocs[pid]
  if not pos then return {} end

  local x = pos[1]
  local y = pos[2]

  local even = math.floor(y/2) == y/2
  local d = even and -1 or 1
  local ls = { {x-1,y}, {x+1,y}, {x,y-1}, {x,y+1},{x+d,y-1},{x+d,y+1}}
  local r = {}
  for i,l in ipairs(ls) do
    local i = locId(l)
    if allLocs[i] then push(r,i) end
  end
  return r
end



-------------------------------------------------------------------------------
-- State



local VERSION = 9

function gsNew()
  local gs = {}

  gs.version = VERSION      -- to avoid save state confusion during development
  gs.turn = 0               -- global turn counter, identifies save states

  gs.pnum = 0               -- how many players we have
  gs.players = {}           -- player colors (serve as ID)
  gs.playerState = {}       -- state for each player, indexed by color

  gs.ageLocs = {}           -- locations part of each age
  gs.buildingFor = {}       -- which building to use when completing loc

  gs.availableSiteNum = 0   -- how many sites are still available to build
  gs.availableSites = {}    -- locations of available sites
  gs.activeSites = {}       -- sites under constructions

  gs.currentAge = 0         -- the current age
  gs.curPlayer = 0      -- the current player

  gs.leaders = {}          -- leaders available for the takings

  gs.mode = 1               -- which flavor of the rules we are using

  gs.baseEvent = nil        -- event from age 1
  gs.baseEvent = nil        -- event from age 1
  gs.wonRace = nil          -- first player to win the baseEvent, if a race
  gs.event = nil            -- event for other ages

  gs.finished = false

  return gs
end


function gsNewPlayer(gs, p)

  local s = {}

  s.owns = {}     -- buildings we completed
  s.score = 0     -- VPS
  s.arch = nil    -- location of architect

  s.active = 3    -- activeA workers

  local pnum = gs.pnum
  s.passive = pnum == 3 and 22 or
              pnum == 4 and 19 or
              pnum == 5 and 17
  -- s.passive = 3 -- XXX

  s.leader = 0
  s.arch2  = nil  -- location of 2nd architect

  -- influence
  local zone = {}
  for i = 1,5 do
    zone[i] = 0
  end
  s.zone = zone

  gs.playerState[p] = s

  return gs
end



function gsSetupPlayers(gs,ps)

  gs.pnum = #ps
  gs.players = ps

  for _,p in ipairs(ps) do
    gsNewPlayer(gs,p)
  end
end



function gsSetupAges(gs)

  -- rotate the entries in ana rray
  local function rotate(inA,i)
    local outA = {}
    local ix = i
    for i,x in ipairs(inA) do
      outA[ix] = x
      ix = ix + 1
      if ix > #inA then ix = 1 end
    end
    return outA
  end

  -- shuffle the locations in a district
  local function shuffleGroup(g)
    local a = {}
    local i = 1
    for _,rs in ipairs(g) do
      for _,c in ipairs(rs.spots) do
        a[i] = c
        i = i + 1
      end
    end
    return shuffle(a)
  end

  local num = {4,2,3,2}

  -- assign buildings to the map
  for i,g in ipairs(spotByColor) do
    local ls = shuffleGroup(g)
    local ix = 1
    for age,n in ipairs(rotate(num,i)) do
      local objs = gs.ageLocs[age]
      if not objs then
        objs = {}
        gs.ageLocs[age] = objs
      end

      for z = 1,n do
        -- local loc = ls[ix]
        gs.buildingFor[ls[ix]] = { type = i, age = age, ix = z }
        push(objs,ls[ix])
        ix = ix + 1
      end
    end
  end

end


function gsCurPlayer(gs)
  return gs.players[gs.curPlayer]
end

function gsNextPlayer(gs)
  local n = gs.curPlayer + 1
  if n > gs.pnum then n = 1 end
  gs.curPlayer = n
end













-------------------------------------------------------------------------------
local GUI

function newGUI()
   local ui = {}
   ui.status = nil
   ui.player = {}
   ui.blueDiscs = {}
   ui.finished = {}
   ui.activeSites = {}   -- sites under construction, indexed by location
   ui.leaders = {}
   ui.baseEvent = nil
   return ui
end



function spawnBasics(k)

  local sem = newSem()

  sem.up()
  local b = spawnObject({
    type = "Custom_Token",
    position = { -4.5, 1, 3.5 },
    rotation = { 0, 180, 0 },
    scale = { 9, 1, 9 },
    callback_function = function(o)
      o.setLock(true)
      sem.down()
    end
  })
  b.setCustomObject({
    image = board_url
  })

  GUI.status = spawnObject({
    type = "3DText",
    rotation = { 90, 0, 0 },
    position = { 20, 1.5, 17 }
  })
  GUI.status.setValue("Quebec")

  sem.wait(k)
end


function spawnUndoButton(p,k)
  spawnObject({
    type = "BlockRectangle",
    position = { 30.5, 4, 5 },
    rotation = { 0,90,0 },
    scale = { 1, 0.1, 1 },
    callback_function = function(o)
      o.setLock(true)
      o.setColorTint(playerColor(p))
      o.createButton({
        font_size = 200,
        label = "Start over",
        click_function = "undoTurn",
        rotation = {0,90,0},
        color = playerColor(p),
        font_color = textColor(p),
        width = 1200,
        height = 600,
        position = { 0,1.1,0 },
        tooltip = "Restart " .. playerColorBB(p) .. "'s turn"
      })
      GUI.undo = o
      k()
   end})
end


function spawnAgeLabels(gs, k)
  for g,info in pairs(gs.buildingFor) do
    local t = spawnObject({
      type = "3DText",
      position = grid(g,1.2,0,0.5),
      rotation = { 90,0,0 }
    })
    t.setValue(info.age .. "")
  end
  k ()
end


function spawnBuildingSites(gs, k)
  local sem = newSem()
  for l,_ in pairs(gs.availableSites) do
    sem.up()
    spawnBuildingSite(l, sem.down)
  end

  for l,_ in pairs(gs.activeSites) do
    sem.up()
    spawnBuildingSite(l, sem.down)
  end

  sem.wait(k)
end



function spawnBuildingSite(l,k)
  local o = spawnObject({
    type = "Custom_Token",
    position = grid(l,1.3,0,0),
    scale = {0.75,0.75,0.75},
    rotation = { 0, 180, 0 },
    callback_function = function(o)
      o.setName("Available building site")
      o.setLock(true)
      GUI.blueDiscs[l] = o
      k()
    end
  })
  o.setCustomObject({
    image = site_url,
    type = 2,
    thickness = 0.1
  })
end


function spawnFinishedSite(gs,p,gloc,n,k)

  local b = spawnObject({
    type = "Custom_Token",
    position = grid(gloc,1.3,0,0),
    scale = {0.75,0.75,0.75},
    rotation = { 0,180,0},

    callback_function = function(o)
      o.setLock(true)
      GUI.finished[gloc] = o
      if n > 0 then
        o.createButton({
          font_size = 350,
          label = ownLabels[n],
          click_function = "nop",
          rotation = {0,0,0},
          color = playerColor(p),
          font_color = textColor(p),
          width = 800,
          height = 350,
          position = { 0,0.1,-1.5 }
        })
      end
      k()
    end
  })

  local info = gs.buildingFor[gloc]
  b.setCustomObject({
    type = 2,
    thickness = 0.1,
    image = build_url[info.type][info.age][info.ix]
  })
end



function spawnActiveSite(gs, l, k)
  local site = gs.activeSites[l]
  local p = site.owner
  local s = gs.playerState[p]
  local arch = nil
  if s.arch == l then arch = p end

  spawnArchitect(arch, l, function()
    local sem = newSem()
    for i,cp in ipairs(site.contributors) do
      sem.up()
      spawnBuilding(cp, l, i, sem.down)
    end
    sem.wait(k)
  end)
end

function spawnBuilding(p, loc, i, k)

  local a = i < 3 and -1 or 1
  local b = i == 1 and -1 or 1
  local l = grid(loc,1.8,a,b)

  labelledCube(p,l,hub[loc].requires, function(o)
    o.setName("Building contribution")
    GUI.activeSites[loc].contributors[i] = o
    k()
  end)

end


function spawnArchitect(p,loc,k)
  spawnObject({
    type = "PlayerPawn",
    position = grid(loc,1.4,1,-1),
    callback_function = function(o)
      o.setName("Architect")
      o.setLock(true)
      o.setColorTint(playerColor(p))
      GUI.activeSites[loc] = { archObj = o, contributors = {} }
      k(o)
    end
  })
end


function spawnEvents(gs,k)
  local sem = newSem()
  local i = 0
  if (gs.baseEvent) then
    sem.up()
    spawnEvent(i,gs.baseEvent,true,gs.wonRace,sem.down)
    i = i + 1
  end
  if (gs.event) then
    sem.up()
    spawnEvent(i,gs.event,false,nil,sem.down)
  end
  sem.wait(k)
end


function spawnMarker(p,k)
  local pos = GUI.baseEvent.getPosition()
  GUI.wonRace = spawnObject({
    type = "PlayerPawn",
        position = { pos[1] - 2.5, pos[2], pos[3] - 1.5 },
        callback_function = function(o)
          o.setName("1st place")
          o.setLock(true)
          o.setColorTint(playerColor(p))
          k()
        end
      })
end

function spawnEvent(i,ev,base,marker,k)
  local pos = {21.5,2, 0 - 7 * i}

  local o = spawnObject({
    type = "Custom_Token",
    rotation = { 0, 180, 0 },
    scale = {2,1,2},
    position = pos,
    callback_function = function(o)
      o.setLock(true)
      o.setName("Event")

      local lab = ""
      for i,t in ipairs(events[ev]) do
         local sep = (i == 1) and "" or "\n"
         lab = lab .. sep .. t
      end

      o.createButton({
        font_size = 100,
        label = lab,
        click_function = "nop",
        font_color = {0,0,0},
        width = 1,
        height = 1,
        position = { 0,1.1,0 },
        tooltip = "Event"
      })

      if base then
        GUI.baseEvent = o
      else
        GUI.event = o
      end

      if marker then
        spawnMarker(marker,k)
      else
        k()
      end
    end
  })
  o.setCustomObject({
    image = event_url
  })
end


function spawnLeaders(gs,k)
  local sem = newSem()
  for _,l in pairs(gs.leaders) do
    sem.up()
    spawnLeader(gs.currentAge, nil, l, sem.down)
  end
  sem.wait(k)
end



function spawnPortrait(age,l,pos,o,k)
  pos[3] = pos[3] + 2

  img = spawnObject({
    type = "Custom_Token",
    rotation = { 0, 180, 0 },
    position = pos,
    callback_function = function(me)
      o.addAttachment(me)
      k()
    end
  })
  img.setCustomObject({
   thickness = 0.1,
   image = leader_img_url[l][age]
  })
end

function spawnLeader(age,owner, l, k)
   local pos
   if not owner then
     pos = { -26, 2, 20 - l * 6 }
   else
     pos = playerLeaderLoc(owner)
   end

   obj = spawnObject({
     type = "Custom_Tile",
     rotation = { 0, 180, 0 },
     position = pos,
     callback_function = function(o)
       o.setLock(true)
       local n = leaders[l][age]
       o.setName(n .. "\n" .. zoneName[l] .. " Leader")
       o.setDescription(leaderD[l])
       spawnPortrait(age,l, pos,o,k)
     end
  })
  obj.setCustomObject({
    type = 3,
    thickness = 0.1,
    image = leader_url[l]
  })




  GUI.leaders[l] = obj
end





function spawnPlayers(gs,k)
  local sem = newSem()
  local j = gs.pnum < 5 and 1 or 0
  for i,p in ipairs(gs.players) do
    local ttsp = Player[p]
    ttsp.setHandTransform({
      position = {-33 + (j + i) * 11, 4.5, -17 },
      scale = { 6, 4.3, 6 },
    })
    ttsp.setCameraMode("TopDown")
    sem.up()
    spawnPlayer(gs,p,sem.down)
  end
  sem.wait(k)
end


function spawnPlayer(gs,p,k)

  -- UI stuff for this player goes here
   local ui = {}
   GUI.player[p] = ui

  local ttsp = Player[p]
  local l = ttsp.getHandTransform().position
  l.z = l.z + 2
  l.y = 1.5
  local i
  for j,q in ipairs(gs.players) do
    if p == q then i = j end
  end
  local dx = (i-1) % 3
  local dz = -math.floor((i-1)/3)


  -- zone UI objects go here
  local zoneObj = {}
  ui.zoneObj = zoneObj

  -- READ ONLY
  local s = gs.playerState[p]


  local todo = newSem()

  -- Spawn zone counters
  for z = 1,5 do
   local l = zoneLoc[z]
   local loc = { l[1] + dx, 2, l[2] + dz}
   todo.up()
   labelledCube(p,loc,s.zone[z], function(o)
     o.setName(zoneName[z] .. " influence")
     zoneObj[z] = o
     todo.down()
   end)
  end

  -- Spawn active workers
  todo.up()
  labelledCube(p, l, s.active, function(o)
    o.setName("Active workers")
    ui.activeObj = o
    todo.down()
  end)
  todo.up()
  ui.hammer = spawnObject({
    type = "Custom_Token",
    position = { l[1], l[2], l[3] - 1.25 },
    rotation = { 0, 180, 0 },
    scale = {0.3, 0.3, 0.3},
    callback_function = function(o)
      o.setColorTint(playerColor(p))
      o.setName("Active worklers")
      todo.down()
    end
  })
  ui.hammer.setCustomObject({
    image = hammer_url
  })

  -- Passive workers
  l.x = l.x + 2
  todo.up()
  labelledCube(p, l,s.passive, function(o)
    o.setName("Passive workers")
    ui.passiveObj = o
    todo.down()
  end)

  -- Score
  todo.up()
  scoreLab = spawnObject({
    type = "Custom_Token",
    position = { l[1] - 1.5, l[2], l[3] + 2 },
    scale = { 0.5, 0.5, 0.5 },
    rotation = { 0, 180, 0 },
    callback_function = function(o)
      o.setLock(true)
      o.setName("Vicotry points")
      ui.scoreLabel = o
      todo.down()
    end
  })
  scoreLab.setCustomObject({
    image = vp_tile_url
  })

  scoreText = spawnObject({
    type = "3DText",
    position = { l[1], l[2], l[3] + 2.4 },
    rotation = { 90,0,0 }
  })
  scoreText.setValue(s.score .. "")
  ui.scoreText = scoreText


  -- Architects
  if (s.arch) then
    todo.up()
    spawnActiveSite(gs, s.arch, todo.down)
  end

  if (s.arch2) then
    todo.up()
    spawnActiveSite(gs, s.arch2, todo.down)
  end

  for l,stars in pairs(s.owns) do
    todo.up()
    spawnFinishedSite(gs, p, l, stars, todo.down)
  end


  -- Leader
  if s.leader > 0 then
    todo.up()
    spawnLeader(gs.currentAge, p, s.leader, todo.down)
  end

  todo.wait(k)

end




function labelledCube(p,loc,amt,k)

  spawnObject({
    type = "BlockSquare",
    position = loc,
    scale = { 0.75, 0.75, 0.75 },
    callback_function = function(o)
      o.setLock(true)
      o.setColorTint(playerColor(p))
      o.createButton({
        font_size = 400,
        label = amt,
        click_function = "nop",
        rotation = {0,180,0},
        font_color = textColor(p),
        width = 0,
        height = 0,
        position = { 0,0.75,0 }
      })
      if k then k(o) end
    end
  })
end

function nop(x) end






-------------------------------------------------------------------------------
-- Interacting with the players



-- Ask to choose among a bunch of text labels
function askText(p, q, labs, k)
  local x = 16
  local y = 2
  local z = 15

  local ls = {}
  local objs = {}

  for i,l in ipairs(labs) do
    local zz = z - 2 * i
    ls[i] = {x,zz-0.3,90 }
    local t = spawnObject({
      type = "3DText",
      position = { x+2, y, zz },
      rotation = { 90,0,0 }
    })
    t.setValue(l)
    local b = t.getBounds().size.x / 100
    t.setPosition { x + 2 + b/2, y, zz }
    objs[i] = t
  end

  local function ans(i)
    for _,o in ipairs(objs) do
       o.destroy()
    end
    k(i)
  end

  ask(p,q, ls,ans)

end



-- Ask to choose a location on the map
function askLocs(p, q, ls, k)


  local ptrs = {}
  for i,l in ipairs(ls) do
    local pos = grid(l,2,0,0)
    ptrs[i] = { pos[1]+1.5, pos[3], -90 }
  end

  ask(p, q, ptrs, k)
end


-- Ask to choose a zone
function askZone(p, q, zs, k)
  local ps = {}
  for i,z in ipairs(zs) do
    ps[i] = zoneArrow[z]
  end

  ask(p, q, ps,k)
end


function askLeader(p, ls, k)
  local locs = {}
  for i,l in ipairs(ls) do
    local pos = GUI.leaders[l].getPosition()
    locs[i] = { pos.x - 2, pos.z, 90 }
  end
  ask(p, "Choose Leader", locs, k)
end


function ask(p, q, locs, k)

  local ql = spawnObject({
    type = "3DText",
    position = {19.5,2,15},
    rotation = {90,0,0}
  })
  ql.setValue(q)


  local markers = {}

  local finished = false

  local function cleanUp()
    for i,m in ipairs(markers) do
      _G["ask" .. i] = nil
      m.destroy()
    end
    ql.destroy()
  end

  local function btn(i,m)
    _G["ask" .. i] = function (obj,c,alt)
       if finished then return end
       if p and c ~= p then
          say(playerColorBB(c) .. " cannot press " .. playerColorBB(p) .. "'s buttons.")
          return --  XXX: disabled for development
       end
       finished = true
       cleanUp()
       k(i)
    end
    m.createButton({
      label = ">",
      font_size = 250,
      width = 300,
      height = 300,
      rotation = { 90, 90, 0},
      position = { 0, 0.05, -1 },
      color = playerColor(p),
      font_color = textColor(p),
      click_function = "ask" .. i
    })
  end

  for ix,i in ipairs(locs) do
    markers[ix] = spawnObject({
      type = "BlockTriangle",
      position = { i[1],2,i[2] },
      scale = { 1, 1, 0.2},
      rotation = { 90, i[3], 0 },
      callback_function = function(o)
        o.setLock(true)
        o.setColorTint(playerColor(p))
        o.highlightOn({0,0,0}, 5 * 60)
        btn(ix,o)
      end
    })
  end

end





function say(x)
  printToAll(x, {1,1,1})
end


function playerColorBB(p)
  local c = playerColor(p)
  return string.format("[%02x%02x%02x]" .. p .. "[-]",
    math.floor(c[1] * 255),
    math.floor(c[2] * 255),
    math.floor(c[3] * 255))
end


function playerColor(p)
  if not p then return { 1, 1, 0 } end -- Yellow
  if p == "White" then return { 0.9, 0.9, 0.9 } end -- White os broken
  return stringColorToRGB(p)
end

function textColor(p)
  local col = playerColor(p)
  local fcol = {0,0,0}
  if (col[1] + col[2] + col[3]) / 3 < 0.9 then fcol = { 1,1,1 } end
  return fcol
end

--------------------------------------------------------------------------------



-------------------------------------------------------------------------------

function reset()
  for _,o in pairs(getAllObjects()) do
    o.destroy()
  end
end

function onLoad(s)

  reset()

  GUI = newGUI()

  q = actQ()
  q.enQ(|| spawnBasics(q.next))
  q.enQ(|| staticMapSetup(q.next))
  q.enQ(function ()
    local gs = loadGame(s)
    if not gs then noGame()
              else finishGUI(gs,||takeTurn(gs)) end
  end)

end




local saveState1 = nil -- one older
local saveState = nil
local cleanSave

function onSave()
  return saveState
end

function saveGame(gs)
  saveState1 = saveState
  saveState = JSON.encode(gs)
  cleanSave = true
end

function loadGame(s)
  if not s then return nil end
  local gs = JSON.decode(s)
  if not gs or gs.version ~= VERSION then return nil end

  saveState1 = nil
  saveState = s
  cleanSave = true
  return gs
end


function undoTurn()
  onLoad(saveState)
end



-------------------------------------------------------------------------------
-- Turns and Rounds



function noGame()
  saveState = nil
  askText(nil, "Ready?", { "Start Without Events", "Start With Events" }, function(mode)
    local ps = {"Green","White","Pink"} -- XXX: DEVELOP
    ps = getSeatedPlayers() -- XXX: Develop
    if (#ps < 3) then
      say("The game requires at least 3 players.")
      noGame()
    else
      startNewGame(ps, mode)
    end
  end)
end

function finishedGame(gs)
  GUI.status.setValue("Game Over")
  say("\nGame Over")
  local scores = {}
  for p,s in pairs(gs.playerState) do
    push(scores, { player = p, score = s.score })
  end
  table.sort(scores, |x,y| x.score > y.score)

  local place = 0
  local prevScore = 1000000
  local msg = "\n\n\n\nFinal Score:\n"
  for _,s in ipairs(scores) do
    if s.score < prevScore then place = place + 1 end
    local txt =  place .. ". " .. playerColorBB(s.player) .. ": " .. s.score .. " VP"
    say(txt)
    msg = msg .. "\n" .. txt
    prevScore = s.score
  end

  askText(nil, msg, {}, ||0)

end


function startNewGame(ps, mode)
  saveState = nil
  local gs = gsNew()
  gs.mode = mode
  gsSetupPlayers(gs,shuffle(ps))
  gsSetupAges(gs)
  gs.curPlayer = 1
  gs.turn = 1

  finishGUI(gs, ||startAge(gs, function()
     saveGame(gs)
     takeTurn(gs)
  end))
end


function ageName(n)
  if n < 1 then return "Quebec" end
  if n > 4 then return "Game Over" end
  local year = { "1608", "1708", "1808", "1908" }
  return n .. ". " .. zoneName[n] .. " Age (" .. year[n] .. ")"
end

-- Start playing either from a save state, or a new game
function finishGUI(gs, k)
  local q = actQ()

  local title = GUI.status
  local header = ageName(gs.currentAge)
  title.setValue(header)

  q.enQ(|| spawnAgeLabels(gs,q.next))
  q.enQ(|| spawnBuildingSites(gs,q.next))
  q.enQ(|| spawnLeaders(gs,q.next))
  q.enQ(|| spawnEvents(gs,q.next))
  q.enQ(|| spawnPlayers(gs, q.next))
  q.enQ(k)
end



function startAge(gs, k)

  local sem = newSem()

  gs.currentAge = gs.currentAge + 1
  local nm = ageName(gs.currentAge)
  say(nm)

  local title = GUI.status
  title.setValue(nm)

  gs.leaders = {1,2,3,4,5}
  sem.up()
  spawnLeaders(gs, sem.down)

  for i,l in ipairs(gs.ageLocs[gs.currentAge]) do
    -- if i > 1 then break end  -- XXX
     -- if math.floor(i % 3) == 1 then -- XXX
    sem.up()
    gs.availableSiteNum = gs.availableSiteNum + 1
    gs.availableSites[l] = true
    spawnBuildingSite(l, sem.down)
    -- end
  end

  if gs.mode == 2 then
    local age = gs.currentAge
    local opts = eventsByAge[age]
    if #opts > 0 then
      local n = math.random(#opts)
      -- n = 3 -- XXX
      local e = opts[n]
      if age == 1 then gs.baseEvent = e else gs.event = e end
      sem.up()
      spawnEvents(gs, function()
        check1867(gs)
        sem.down()
      end)
    end
  end

  sem.wait(k)
end


function check1867(gs)
  if gs.event ~= "e1867" then return end

  say("1867 Event")
  local scores = {}
  for p,s in pairs(gs.playerState) do
    push(scores, { player = p, score = s.score })
  end
  table.sort(scores, |x,y| x.score > y.score)
  local rank = 0
  local maxScore = 100000
  for _,p in ipairs(scores) do
    if p.score < maxScore then
      rank = rank + 1
      maxScore = p.score
    end
    activate(gs,p.player,rank)
  end

end



function endAge(gs, k)
  GUI.status.setValue(gs.currentAge .. ". Ending " ..
                               zoneName[gs.currentAge] .. " Age")
  say("\nEnding " .. zoneName[gs.currentAge] .. " Age")

  -- Finish Yellow Architect
  for _,p in ipairs(gs.players) do
    local s = gs.playerState[p]
    if s.arch2 then
      finishBuilding(gs,p, s.arch2, || reallyEndAge(gs,k))
      return
    end
  end

  reallyEndAge(gs,k)
end



function reallyEndAge(gs,k)

   -- destroy and return leaders
  for _,p in ipairs(gs.players) do
    local s = gs.playerState[p]
    s.leader = 0
    s.arch2 = nil
  end
  for l = 1,5 do
    GUI.leaders[l].destroy()
  end

  -- Sites that didn't get started are gone
  for l,_ in pairs(gs.availableSites) do
    GUI.blueDiscs[l].destroy()
    GUI.blueDiscs[l] = nil
  end
  gs.availableSiteNum = 0
  gs.availableSites = {}

  -- End of round scoring
  local winners = {}
  local prevZ

  local function scoreZ(z,k)
    prevZ = z
    say("\nScoring " .. zoneName[z] .. " influence")
    winners = {}
    local scores = {}
    local winScore = 0
    for _,p in ipairs(gs.players) do
      local s = gs.playerState[p]
      local n = s.zone[z]
      if n > winScore then
        winners = {p}
        winScore = n
      elseif n == winScore then
        push(winners,p)
      end
      scorePoints(gs,p,n)
      scores[p] = n
    end
    if gs.event == "e1759" and z == 5 then
      say("1759: Everyone cascades.")
      winners = gs.players
    end

    local msg = zoneName[z] .. " Score\n\n\n\n"
    for p,vp in pairs(scores) do
      msg = msg .. "\n" .. playerColorBB(p) .. ": " .. vp .. " VP"
    end

    askText(gsCurPlayer(gs), msg, {"Continue"}, k)
  end

  local noCascade = {}
  if gs.event == "e2008" then
    for p,s in pairs(gs.playerState) do
      local count = 0
      for i = 1,4 do
        if s.zone[i] > 0 then count = count + 1 end
      end
      if count < 4 then
        say("\n2008: " .. playerColorBB(p) .. " may not cascade.")
        noCascade[p] = true
      end
    end
  end


  local function cascade(p, from, to)
    local s = gs.playerState[p]
    local have = s.zone[from]
    local n = math.floor(have / 2)
    if n == 0 then return end
    if n > 5 then n = 5 end

    local mayCascade = not noCascade[p]
    if gs.event == "e2001" and to and s.zone[to] == 0
       then say("\n2001: " .. playerColorBB(p) ..
                " may not cascade to " .. zoneName[to] .. ".")
            mayCascade = false
       end

    if mayCascade then
      setZone(gs,p,from,have - n)
      if to then
        setZone(gs,p,to,s.zone[to] + n)
        moveCubeEffect(p,powerZoneLoc(from),powerZoneLoc(to))
      else
        setActive(gs,p,s.active + n)
      end
    end
  end

  local function finishZone(from,to)
    for _,p in ipairs(winners) do
      cascade(p,from,to)
    end
    for _,p in ipairs(gs.players) do
      local s = gs.playerState[p]
      local have = s.zone[from]
      if have > 0 then
        setZone(gs,p,from,0)
        setPassive(gs,p,s.passive + have)
        moveCubeEffect(p,powerZoneLoc(from),playerZoneLoc(p))
      end
    end
  end

  local q = actQ()

  check1917(gs)
  check1955(gs)

  q.enQ(||scoreZ(5, q.next))

  for a = 0,3 do

    q.enQ(function()
      local next = gs.currentAge + a
      if next > 4 then next = next - 4 end
      finishZone(prevZ,next)
      scoreZ(next,q.next)
    end)
  end

  q.enQ(function()
    finishZone(prevZ,nil)
    if gs.event then
      check1871(gs)
      gs.event = nil
      GUI.event.destroy()
    end
    if gs.currentAge == finalAge then endGame(gs) else startAge(gs, k) end
  end)

end

function check1871(gs)
  if gs.event ~= "e1871" then return end

  for p,s in pairs(gs.playerState) do
    local a = s.active
    if a > 3 then
      say("\n1871: Active workers for " .. playerColorBB(p) .. " reduced to 3.")
      setActive(gs,p,3)
      setPassive(gs,p,s.passive + a - 3)
    end
  end
end

function check1955(gs)
  if gs.event ~= "e1955" then return end
  for p,s in pairs(gs.playerState) do
    local count = 0
    for z = 1,5 do
      if s.zone[z] > 0 then count = count + 1 end
    end
    if count == 5 then
      say("\n1955")
      scorePoints(gs,p,5)
    end
  end
end

function check1917(gs)
  if gs.event ~= "e1917" then return end
  for p,s in pairs(gs.playerState) do
    for z = 1,5 do
      local n = s.zone[z]
      if 1 <= n and n <= 2 then
        say("\n1917: " .. playerColorBB(p) .. " lost " .. zoneName[z] .. " influence.")
        setZone(gs,p,z,0)
        setPassive(gs,p,s.passive + n)
        moveCubeEffect(p, powerZoneLoc(z), playerZoneLoc(p))
      end
    end
  end
end


function endGame(gs)

  say("\nEnd Game Scoring")

  say("\nScoring Unfinished Buildings")
  for l,site in pairs(gs.activeSites) do
    local r = hub[l].requires
    for _,p in ipairs(site.contributors) do
      scorePoints(gs,p,r)
    end
  end

  say("\nScoring Active Workers")
  for p,s in pairs(gs.playerState) do
    scorePoints(gs,p,math.floor(s.active/2))
  end

  say("\nScoring Completed Buildings")
  local owned = {}
  for p,s in pairs(gs.playerState) do
    for l,_ in pairs(s.owns) do
      owned[l] = p
    end
  end

  local areas = findAreas(owned)
  for _,p in ipairs(gs.players) do
    if not areas[p] then areas[p] = { } end
  end

  for p,as in pairs(areas) do
    local largest = nil

    local stars = gs.playerState[p].owns

    local mainT = { 1,3,6 }
    local pts = 0
    local maxPtsSmall = 0
    local maxPtsBig = 0

    for r,a in pairs(as) do
      local v1 = 0
      local v2 = 0

      for _,l in ipairs(a) do
         local s = stars[l]
         v1 = v1 + s
         v2 = v2 + mainT[s]
      end
      if v2 > maxPtsBig
         then pts = pts + maxPtsSmall
              maxPtsSmall = v1
              maxPtsBig = v2
         else pts = pts + v1
      end
    end
    pts = pts + maxPtsBig
    scorePoints(gs,p,pts)
  end

  if gs.baseEvent == "e1603" then score1603(gs,areas) end

  gs.finished = true
  finishedGame(gs)
end



function score1603(gs,areas)
  say("\nScoring 1603 Event")
  local winners = {}
  local largestA = 1
  for p,as in pairs(areas) do
    local largestP = 0
    for _,a in pairs(as) do
      if #a > largestP then largestP = #a end
    end
    if largestP > largestA then
       largestA = largestP
       winners = {p}
    elseif largestP == largestA then
       push(winners,p)
    end
  end

  for _,p in ipairs(winners) do
    scorePoints(gs,p,8)
  end

end


function takeTurn(gs)
  if (gs.finished) then finishedGame(gs); return end

  local ready = false
  local p = gsCurPlayer(gs)
  local s = gs.playerState[p]

  if s.active == 0 and s.passive == 0 then
    endAge(gs,function()
      if gs.currentAge <= finalAge then takeTurn(gs) end
    end)
  else
     chooseAction(gs)
  end
end

function nextTurn(gs)
  local p = gsCurPlayer(gs)
  askText(p, playerColorBB(p) .. "' turn:", { "End Turn" }, function (i)
    GUI.undo.destroy()
    GUI.undo = nil
    gsNextPlayer(gs)
    gs.turn = gs.turn + 1
    saveGame(gs)
    takeTurn(gs)
  end)
end



----------------------
-- Common player actions

function effect(o)
  local x0 = o.getRotation()[2]
  o.rotate({0,25,0})
  Wait.frames(|| o.rotate({0,-35,0}), 20)
  Wait.frames(|| o.rotate({0,10,0}), 40)
  Wait.frames(function ()
    local x = o.getRotation()[2]
    o.rotate({0,x0-x,0})
  end, 60)
end

function moveCubeEffect(p, p1, p2)
  spawnObject({
    type = "BlockSquare",
    position = p1,
    scale = { 0.75, 0.75, 0.75 },
    callback_function = function(o)
      o.setLock(true)
      o.setColorTint(playerColor(p))
      o.setPositionSmooth(p2, false, false)
      Wait.condition(|| Wait.frames(||o.destroy(),60), || o.resting)
    end
  })
end

function playerZoneLoc(p)
  return Player[p].getHandTransform().position
end

function powerZoneLoc(z)
  local x = zoneArrow[z]
  return { x[1], 3, x[2] }
end



function activate(gs,p,n)
  local s = gs.playerState[p]
  if s.passive < n then n = s.passive end
  say(playerColorBB(p) .. " activated " .. n .. " workers")
  setPassive(gs,p, s.passive - n)
  setActive(gs,p, s.active + n)
  return n
end

function addZone(gs,p,z,n)
  if n == 0 then return end
  local s = gs.playerState[p]
  setZone(gs,p,z,s.zone[z] + n)
  local event = n >= 0 and (" gained " .. n)
                      or (" lost " .. -n)
  say(playerColorBB(p) .. event .. " " .. zoneName[z] .. " influence")
end


function setActive(gs,p,n)
  local s = gs.playerState[p]
  local ui = GUI.player[p]
  s.active = n
  setLabel(ui.activeObj,n)
end

function setPassive(gs,p,n)
  local s = gs.playerState[p]
  local ui = GUI.player[p]
  s.passive = n
  setLabel(ui.passiveObj,n)
end

function setZone(gs,p,z,n)
  local s = gs.playerState[p]
  local ui = GUI.player[p]
  s.zone[z] = n
  setLabel(ui.zoneObj[z],n)
end



function scorePoints(gs,p,n)
  local s = gs.playerState[p]
  local ui = GUI.player[p]
  s.score = s.score + n
  ui.scoreText.setValue(s.score .. "")
  effect(ui.scoreLabel)
  say(playerColorBB(p) .. " scored " .. n .. " point"
                                          .. (n ~= 1 and "s" or ""))
end


function placeBuilding(gs,p,loc,k)
  local site = gs.activeSites[loc]
  push(site.contributors, p)
  local nth = #site.contributors
  spawnBuilding(p,loc,nth,function()
    moveCubeEffect(p,playerZoneLoc(p),grid(loc,3,0,0))
    say(playerColorBB(p) .. " contributed to "
         .. playerColorBB(site.owner) .. "'s building in the " ..
                      hub[loc].name)
    k()
  end)
end


function bumpSite(gs,p,gloc)
  local s = gs.playerState[p]
  local stars = s.owns[gloc] + 1
  s.owns[gloc] = stars
  setLabel(GUI.finished[gloc],ownLabels[stars])
end


function markSite(gs,p,gloc,n,k)
  if n == 0 then k(); return end
  if n == 1 and gs.event == "e1775" then
      say("1775: " .. playerColorBB(p) .. " does not get an ownership token.")
      k()
      return
  end

  local s = gs.playerState[p]
  local col = playerColor(p)
  local fcol = textColor(p)

  if s.leader == 4 then
    local pts = n
    if gs.pnum > 3 then pts = pts + 1 end
    say(playerColorBB(p) .. " used the " .. zoneName[4] .. " leader.")
    scorePoints(gs,p, pts)
  end

  s.owns[gloc] = n

  checkRaceEvents(gs,p)


  spawnFinishedSite(gs,p,gloc,n,k)
end


function checkRaceEvents(gs,p)
  local owns = gs.playerState[p].owns

  local function event1665()
    local has = {}
    local count = 0
    for l,n in pairs(owns) do
      if n == 3 then
        local c = hub[l].color
        if not has[c] then has[c] = true; count = count + 1 end
      end
    end
    return count == 4
  end

  local function event1663()
    local has = {}
    local count = 0
    for l,_ in pairs(owns) do
      local c = hub[l].color
      if not has[c] then has[c] = 1
      elseif has[c] == 1 then has[c] = 2; count = count + 1
      end
    end
    return count >= 3
  end

  local function event1682()
    local count = 0
    for l,_ in pairs(owns) do
      if hub[l].color == 4 then count = count + 1 end
    end
    return count >= 3
  end

  if gs.wonRace == p then return end

  local success =
     (gs.baseEvent == "e1663") and event1663() or
     (gs.baseEvent == "e1665") and event1665() or
     (gs.baseEvent == "e1682") and event1682() or
     false

  if not success then return end

  if not gs.wonRace then
    gs.wonRace = p
    say(playerColorBB(p) .. " is 1st to achieved the objective")
    scorePoints(gs,p,8)
    spawnMarker(p,||1)
  else
    say(playerColorBB(p) .. " is 2nd to achieve the objective")
    scorePoints(gs,p,4)
    gs.baseEvent = nil
    gs.wonRace = nil
    GUI.baseEvent.destroy()
    GUI.baseEvent = nil
    if GUI.wonRace then GUI.wonRace.destroy(); GUI.wonRace = nil; end
  end

end


function playerLeaderLoc(p)
  local ttsp = Player[p]
  local pos = ttsp.getHandTransform().position
  pos.x = pos.x - 3
  pos.z = pos.z + 1
  pos.y = 1.5
  return pos
end

function gainLeader(gs,p,l)
  local s = gs.playerState[p]
  gs.leaders[l] = nil
  s.leader = l
  local obj = GUI.leaders[l]
  obj.setPositionSmooth(playerLeaderLoc(p),false,false)
end



-----------------------------------------------------------------------------
-- Player actions


function chooseAction(gs)

   local p = gsCurPlayer(gs)
   say("\nTurn #" .. gs.turn .. ": " .. playerColorBB(p) .. "'s turn")
   local s = gs.playerState[p]

   local acts = {}
   local actFun = {}
   local function addAct(txt,f)
     push(acts,txt)
     push(actFun, || spawnUndoButton(p,||f()))
   end

   addAct("Start Building", || startBuilding(gs))

   local contr = {}
   for l,info in pairs(gs.activeSites) do
     if #info.contributors < 3 and hub[l].requires <= s.active then
       push(contr,l)
     end
   end

   if #contr > 0 then
     addAct("Contribute", || contribute(gs,contr))
   end

   if s.active > 0 then
     addAct("Gain 1 Influence", || zoneWorker(gs))
   end

   if s.leader == 0 and gs.event ~= "e1763" then
     addAct("Take Leader", || takeLeader(gs))
   end

   askText(p, playerColorBB(p) .. "'s turn:", acts,|i| actFun[i]() )

end




function startBuilding(gs)
  local p = gsCurPlayer(gs)
  local s = gs.playerState[p]
  local gloc

  if s.leader == 3 then
    askText( p
           , "Which architect?"
           , { "Use " .. playerColorBB(p) .. " architect"
             , "Use [FFFF00]Yellow[-] architect"
            }, function(i)
        if i == 2 then
          say(playerColorBB(p) .. " uses the " .. zoneName[3] .. " leader.")
        end
        startBuildingWith(gs,p, i == 2)
    end)
  else
    startBuildingWith(gs,p,false)
  end
end



function startBuildingWith(gs,p,extra)
  local s = gs.playerState[p]

  local gloc
  if extra then gloc = s.arch2 else gloc = s.arch end

  local function oldSiteDone()
    local function finishTurn()
      if extra and s.leader ~= 3 then nextTurn(gs); return end -- round ended

      local sites = {}
      local function buildOn(i)
        local newLoc = sites[i]

        gs.availableSites[newLoc] = nil
        gs.availableSiteNum = gs.availableSiteNum - 1

        local newSite = { owner = p, contributors = {} }
        gs.activeSites[newLoc] = newSite
        if extra then s.arch2 = newLoc else s.arch = newLoc end


        say (playerColorBB(p) .. " started a building in the " ..
                                                        hub[newLoc].name)

        local col = p
        if extra then col = nil end
        spawnArchitect(col, newLoc,
          function()
            if gs.event == "e1812" then
              say("1812: activate 1 fewer worker.")
              activate(gs,p,2)
            elseif gs.event == "e1800" then
              say("1800---1830: activate 1 additional worker.")
              activate(gs,p,4)
            else
              activate(gs,p,3)
            end
            nextTurn(gs)
          end)
      end

      local ptrs = {}
      local ix = 1
      for l,_ in pairs(gs.availableSites) do
        local pos = grid(l,2,0,0)
        sites[ix] = l
        ptrs[ix] = { pos[1]+1.5, pos[3], -90 }
        ix = ix + 1
      end

      ask(p, "New Building Site", ptrs, buildOn)
    end

    if gs.availableSiteNum == 0 then
    endAge(gs,finishTurn)
    else
      finishTurn()
    end
  end

  if gloc then
     finishBuilding(gs,p,gloc, oldSiteDone)
  else
     oldSiteDone()
  end

end




function finishBuilding(gs,p,gloc, k)
  local s = gs.activeSites[gloc]
  local ui = GUI.activeSites[gloc]
  local stars = #s.contributors
  local district = hub[gloc]

  say(playerColorBB(p) .. " completed a " .. stars ..
                          " star building in the " .. district.name)

  local sem = newSem()
  local polAsked = false
  local polChosen = nil
  for ci,c in ipairs(s.contributors) do
    sem.up()
    local ps = gs.playerState[c]
    local tgtZ = district.color

    local function doPlace(tgtZ)
      ui.contributors[ci].destroy()
      ui.contributors[ci] = nil
      addZone(gs,c,tgtZ,district.requires)
      moveCubeEffect(c, grid(gloc,3,0,0), powerZoneLoc(tgtZ))
      sem.down()
    end

    if ps.leader == 2 then
      if polAsked
        then Wait.condition(||doPlace(polChosen), ||polChosen ~= nil)
        else
          polAsked = true
          say(playerColorBB(c) .. "uses " .. zoneName[2] .. " leader.")
          askZone(c,"Contributions from " .. district.name,{1,2,3,4},
            function(i)
              polChosen = i
              doPlace(i)
            end)
        end
    else
      doPlace(tgtZ)
    end
  end


  sem.wait(function()
    ui.archObj.destroy()
    GUI.activeSites[gloc] = nil
    GUI.blueDiscs[gloc].destroy()
    gs.activeSites[gloc] = nil
    markSite(gs,p,gloc,stars,k)
  end)

end




function contribute(gs,ls)
  cleanSave = false
  local p = gsCurPlayer(gs)
  askLocs(p, "Building for Contribution", ls, function(i)
    local gloc = ls[i]
    local s = gs.playerState[p]
    local district = hub[gloc]
    setActive(gs,p,s.active - district.requires)

    placeBuilding(gs,p, gloc, function()
      local owner = gs.activeSites[gloc].owner
      if s.leader == 1 or owner ~= p then
        if s.leader == 1 and owner == p then
          say(playerColorBB(p) .. " activates the " .. zoneName[1] .. " leader.")
        end
        district.act(gs,gloc)
      else
        nextTurn(gs)
      end
    end)
  end)
end


function zoneWorker(gs)
  cleanSave = false
  local p = gsCurPlayer(gs)
  local function doAdd(z)
    local s = gs.playerState[p]
    setActive(gs,p,s.active - 1)
    addZone(gs,p,z,1)
    moveCubeEffect(p,playerZoneLoc(p),powerZoneLoc(z))
    nextTurn(gs)
  end
  askZone(gsCurPlayer(gs), "Influence Authorithy", {1,2,3,4,5}, doAdd)
end


function takeLeader(gs)
  cleanSave = false
  local p = gsCurPlayer(gs)
  local avail = {}
  for _,l in pairs(gs.leaders) do
    push(avail,l)
  end
  askLeader(p,avail,function(i)
    local l = avail[i]
    say(playerColorBB(p) .. " took the " .. zoneName[l] .. " Leader.")
    if gs.event ~= "e1756" then
       activate(gs,p, 5 - #avail)
    else say("1756--1763: No worker activation")
    end

    gainLeader(gs,p,l)
    if l == 5 then
       sendNum(gs,p,"Influence Citadelle",3, function(pa,ac)
         local s = gs.playerState[p]
         setActive(gs,p,s.active-ac)
         setPassive(gs,p,s.passive-pa)
         addZone(gs,p,5,pa+ac)
         moveCubeEffect(p,playerZoneLoc(p),powerZoneLoc(5))
         nextTurn(gs)
       end)
    else
      nextTurn(gs)
    end
  end)
end






------------------------------------------------------------------------------
-- Actions form the districts



function chooseDistrict(c)
  return function(gs,l)
    local opts = { }
    for i = 1,3 do
      opts[i] = spotByColor[c][i+1].id
    end
    askLocs(gsCurPlayer(gs), "District to Activate", opts,|i| spotByColor[c][i+1].act(gs,l))
  end
end




function sendNum(gs,p,q,num,k)
  local s = gs.playerState[p]
  local opts = { "Send 0" }
  local pa = { {0,0} }

  for i = 1,num do
    local j = i
    if j > s.passive then j = s.passive end
    local a = i - j
    if a > s.active then a = s.active end
    if (a + j) == i then
      pa[i + 1] = { j, a}
      local pass = (j > 0) and " " .. j or ""
      local extra = (a > 0) and (" " .. a .. " active") or ""
      local jn = (j > 0 and a > 0) and " and" or ""
      opts[i+1] = "Send" .. pass .. jn .. extra
    end
  end

  askText(p, q, opts, |i| k(pa[i][1],pa[i][2]))
end




-- The current player has the option to gain some influence
function addInfluence(gs,num,q,zs,k)
  local p = gsCurPlayer(gs)

  sendNum(gs, p, q, num, function(j,a)
    if j + a == 0 then
      k()
    else
      local function sendTo(z)
        local s = gs.playerState[p]
        setPassive(gs,p, s.passive - j)
        setActive(gs,p, s.active - a)
        addZone(gs,p, zs[z], a + j)
        moveCubeEffect(p, playerZoneLoc(p), powerZoneLoc(zs[z]))
        k()
      end

      if #zs == 1
        then sendTo(1)
        else askZone(p, "Influence Authority", zs, sendTo)
      end

    end
  end)
end


--------------------------------------------------------------------------------

actions[1][1] = chooseDistrict(1)

actions[1][2] = function(gs)
  local q = actQ()
  q.enQ(||addInfluence(gs, 1, "Citadelle",   {5}, q.next))
  q.enQ(||addInfluence(gs, 1, "Another Authority", {1,2,3,4}, ||nextTurn(gs)))
end

actions[1][3] = function(gs)
  local p = gsCurPlayer(gs)
  scorePoints(gs,p,1)
  activate(gs,p,1)
  addInfluence(gs, 1, "Any Authority",{1,2,3,4,5}, ||nextTurn(gs))
end


actions[1][4] = function(gs)
   local p = gsCurPlayer(gs)
   local k = || nextTurn(gs)
   local s = gs.playerState[p]

   local q = actQ()

   q.enQ(|| addInfluence(gs, 1, "Any Authority", {1,2,3,4,5}, q.next))

   local function maxInfluence()
     local n = 0
     for _,x in ipairs(s.zone) do
       if x > n then n = x end
     end
     return n
   end

   local moveNum
   q.enQ(function()
     local n = maxInfluence()
     if n == 0 then q.stop(); k (); return end
     if n > 2 then n = 2 end
     local opts = { "Move 0" }
     for i = 1,n do
       opts[i+1] = "Move " .. i
     end
     askText(p, "Choose:",opts, function(i)
       if i == 1 then q.stop(); k (); return end
       moveNum = i - 1
       q.next()
     end)
   end)

   local moveFrom
   q.enQ(function()
     local opts = {}
     for z,x in ipairs(s.zone) do
       if x >= moveNum then push(opts,z) end
     end
     askZone(p,"Move from", opts,function(fZ)
       moveFrom = opts[fZ]
       q.next()
    end)
  end)

  local moveTo
  q.enQ(function()
    local ix,to = 1,{}
    for toZ = 1,5 do
      if toZ ~= moveFrom then
        to[ix] = toZ
        ix = ix + 1
      end
    end
    askZone(p,"Move to", to,function(toZ)
      moveTo = to[toZ]
      q.next()
    end)
  end)

  q.enQ(function()
    addZone(gs,p,moveFrom, -moveNum)
    addZone(gs,p,moveTo, moveNum)
    moveCubeEffect(p,powerZoneLoc(moveFrom),powerZoneLoc(moveTo))
    k()
  end)

end


--------------------------------------------------------------------------------


actions[2][1] = chooseDistrict(2)
actions[2][2] = |gs| addInfluence(gs, 2,"Religion/Commerce", {1,3}, ||nextTurn(gs))
actions[2][3] = |gs| addInfluence(gs, 2,"Millitary/Culture", {2,4}, ||nextTurn(gs))
actions[2][4] = |gs| addInfluence(gs, 2,"Citadelle",         {5},   ||nextTurn(gs))


--------------------------------------------------------------------------------

actions[3][1] = chooseDistrict(3)
actions[3][2] = function(gs,loc)

  local p = gsCurPlayer(gs)
  local s = gs.playerState[p]
  local tot = s.passive + s.active
  local contr = {}
  for l,info in pairs(gs.activeSites) do
    if l ~= loc and #info.contributors < 3 and hub[l].requires <= tot then
      push(contr,l)
    end
  end

  if (#contr > 0) then
    askText(p, "Action:", {"Contribute", "Pass"}, function(i)
      if i == 1 then
        askLocs(p, "Building for Contribution", contr,function(i)
          local loc = contr[i]
          local need = hub[loc].requires
          local j = need
          if j > s.passive then j = s.passive end
          setPassive(gs,p, s.passive - j)
          need = need - j
          setActive(gs,p, s.active - need)
          placeBuilding(gs,p,loc,||nextTurn(gs))
        end)
      else
        nextTurn(gs)
      end
    end)

  else
    say("There is nowhere to contribute to.")
    nextTurn(gs)
  end

end

actions[3][3] = function(gs)
  local p = gsCurPlayer(gs)
  askText(p, "Action:", {"Start Building", "Pass"}, function(i)
    if i == 1 then startBuilding(gs) else nextTurn(gs) end
  end)
end

actions[3][4] = function(gs)
  activate(gs,gsCurPlayer(gs),3)
  nextTurn(gs)
end



--------------------------------------------------------------------------------

actions[4][1] = chooseDistrict(4)

actions[4][2] = function(gs)
  local p = gsCurPlayer(gs)
  local s = gs.playerState[p]
  if s.active >= 3 then scorePoints(gs,p,4)
  elseif s.active >= 2 then scorePoints(gs,p,3)
  elseif s.active >= 1 then scorePoints(gs,p,1)
  end
  nextTurn(gs)
end

actions[4][3] = function(gs)
  local p = gsCurPlayer(gs)
  local s = gs.playerState[p]
   local n = 0
   for i = 1,5 do
     if s.zone[i] > 0 then n = n + 1 end
   end
   if n >= 3 then scorePoints(gs,p, 4)
   elseif n == 2 then scorePoints(gs,p, 3)
   elseif n == 1 then scorePoints(gs,p, 1)
   end
   nextTurn(gs)
end

actions[4][4] = function(gs)
  local p = gsCurPlayer(gs)
  local s = gs.playerState[p]
  local opts = {}
  for l,stars in pairs(s.owns) do
    if stars < 3 then push(opts,l) end
  end

  if #opts == 0
  then
     nextTurn(gs)
  else
    askLocs(p, "Building to Upgrade", opts, function(i)
      bumpSite(gs,p,opts[i])
      nextTurn(gs)
    end)
  end

end





------------------------------------------------------------------------------



function setLabel(x,l)
  for _,i in ipairs(x.getButtons()) do
    i.label = l
    x.editButton(i)
  end
  effect(x)
end

function newSem()
  local todo = 0
  return {
    done = || todo == 0,
    up = function() todo = todo + 1 end,
    down = function() todo = todo - 1 end,
    wait = function(k) Wait.condition(function() k() end, || todo == 0) end
  }
end


function actQ()

  local turn = 1
  local slot = 1
  local ans = nil
  local waiting = {}
  return {
    enQ = function(f)
      local me = slot
      slot = slot + 1
      waiting[me] = Wait.condition(f, || turn == me)
    end,
    next = function(i)
      ans = i
      waiting[turn] = me
      turn = turn + 1
    end,
    stop = function()
      for i,x in pairs(waiting) do
        Wait.stop(x)
        waiting[i] = nil
      end
    end

  }
end

function push(xs,x)
  xs[#xs + 1] = x
end


function findAreas(owned)

  local repFor = {}

  local function find(l)
    local r = repFor[l]
    if not r then return l end
    local x = find(r)
    repFor[l] = x
    return x
  end

  local function union(a,b)
    local s1 = find(a)
    local s2 = find(b)
    if s1 == s2 then return end
    repFor[s1] = s2
  end

  for loc,p in pairs(owned) do
    for _,n in ipairs(neighbours(loc)) do
      if p == owned[n] then union(loc,n) end
    end
  end

  local areas = {}
  for loc,p in pairs(owned) do
    local r = find(loc)
    local pas = areas[p]
    if not pas then pas = {}; areas[p] = pas end
    local reg = pas[r]
    if not reg then reg = {}; pas[r] = reg end
    push(reg,loc)
  end

  return areas
end


-- shuffle an array of thing
function shuffle(xs)
  local n = #xs
  local used = {}
  local a = {}
  for i = 1,n do
    local x
    repeat
      x = math.random(n)
    until not used[x]
    used[x] = true
    a[i] = xs[x]
  end
  return a
end
